<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chat Dashboard</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <h2>Chat Dashboard</h2>
    <button onclick="logout()">Logout</button>

    <div id="chat">
      <div id="conversations"></div>
      <div id="messages">
        <div id="messageList"></div>
        <div id="noMessages" class="hidden">No messages in this chat yet.</div>
        <input type="text" id="messageInput" placeholder="Type a message..."/>
        <button onclick="sendMessage()">Send</button>
      </div>
    </div>
  </div>

  <script>
    const apiBase = "https://chat-backend.rsmilga08.workers.dev";
    const userId = sessionStorage.getItem("userId");
    let currentConvo = null;
    let shouldAutoScroll = false;
    let previousMessageCount = 0;
    let lastKnownUpdate = null;
    const expandedMessages = new Set();

    if (!userId) {
      window.location.href = "/login.html";
    }

    async function logout() {
      sessionStorage.clear();
      window.location.href = "/login.html";
    }

    function isScrolledToBottom(el) {
      return el.scrollHeight - el.clientHeight <= el.scrollTop + 1;
    }

    function formatDateTime(timestamp) {
      const date = new Date(timestamp);
      return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
    }

    function toggleMessageExpansion(messageId) {
      if (expandedMessages.has(messageId)) {
        expandedMessages.delete(messageId);
      } else {
        expandedMessages.add(messageId);
      }
      loadMessages();
    }

    async function retractMessage(messageId, unretract = false) {
      try {
        const res = await fetch(`${apiBase}/retractMessage`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message_id: messageId, unretract })
        });
        if (!res.ok) throw new Error(await res.text());
        await loadMessages();
      } catch (err) {
        console.error("Failed to (un)retract:", err);
      }
    }

    async function loadConversations() {
      try {
        const res = await fetch(`${apiBase}/getConversations`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user_id: userId })
        });
        if (!res.ok) throw new Error(await res.text());

        const data = await res.json();
        const container = document.getElementById("conversations");
        container.innerHTML = "";

        data.conversations.forEach((convo) => {
          const el = document.createElement("div");
          el.textContent = convo.username;
          el.className = "convo-item";
          el.onclick = () => {
            currentConvo = convo.convo_id;
            previousMessageCount = 0;
            lastKnownUpdate = null;
            expandedMessages.clear();
            loadMessages();
          };
          container.appendChild(el);
        });
      } catch (err) {
        console.error("Failed to load conversations:", err);
      }
    }

    async function loadMessages() {
      if (!currentConvo) return;

      const list = document.getElementById("messageList");
      const noMsgDiv = document.getElementById("noMessages");

      try {
        const res = await fetch(`${apiBase}/getMessages`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ convo_id: currentConvo })
        });

        if (!res.ok) throw new Error(await res.text());

        const data = await res.json();
        const wasScrolledToBottom = isScrolledToBottom(list);

        list.innerHTML = ""; // Clear messages first

        if (!data.messages || data.messages.length === 0) {
          noMsgDiv.classList.remove("hidden");
          return;
        }

        noMsgDiv.classList.add("hidden");

        if (data.messages.length > previousMessageCount) {
          shouldAutoScroll = true;
        }

        previousMessageCount = data.messages.length;

        const newestUpdate = data.messages.reduce((latest, msg) => {
          const msgTime = new Date(msg.updated_at || msg.timestamp);
          return msgTime > latest ? msgTime : latest;
        }, new Date(0));
        lastKnownUpdate = newestUpdate.toISOString();

        const tempContainer = document.createElement("div");
        tempContainer.style.display = "none";
        document.body.appendChild(tempContainer);

        data.messages.forEach((msg) => {
          const messageContainer = document.createElement("div");
          messageContainer.className = "message-container";

          const messageElement = document.createElement("div");
          messageElement.className = msg.user_id === userId ? "my-message" : "user-message";

          if (msg.retracted) {
            const retractedLabel = document.createElement("span");
            retractedLabel.className = "retracted-label";
            retractedLabel.textContent = "retracted";

            const timestamp = document.createElement("div");
            timestamp.className = "timestamp";
            timestamp.textContent = formatDateTime(msg.timestamp);

            const originalMessage = document.createElement("div");
            originalMessage.className = "original-message";
            originalMessage.textContent = msg.message;

            const actionButtons = document.createElement("div");
            actionButtons.className = "action-buttons";

            if (expandedMessages.has(msg.message_id)) {
              timestamp.style.display = "block";
              originalMessage.style.display = "block";
              actionButtons.style.display = "block";
            }

            if (msg.user_id === userId) {
              const unretractBtn = document.createElement("button");
              unretractBtn.className = "unretract-btn";
              unretractBtn.textContent = "Unretract";
              unretractBtn.onclick = async (e) => {
                e.stopPropagation();
                await retractMessage(msg.message_id, true);
              };
              actionButtons.appendChild(unretractBtn);
            }

            retractedLabel.onclick = () => toggleMessageExpansion(msg.message_id);

            messageElement.appendChild(retractedLabel);
            messageElement.appendChild(originalMessage);
            messageElement.appendChild(timestamp);
            messageElement.appendChild(actionButtons);
          } else {
            messageElement.textContent = msg.message;

            const timestamp = document.createElement("div");
            timestamp.className = "timestamp";
            timestamp.textContent = formatDateTime(msg.timestamp);

            const actionButtons = document.createElement("div");
            actionButtons.className = "action-buttons";

            if (expandedMessages.has(msg.message_id)) {
              timestamp.style.display = "block";
              actionButtons.style.display = "block";
            }

            if (msg.user_id === userId) {
              const retractBtn = document.createElement("button");
              retractBtn.className = "retract-btn";
              retractBtn.textContent = "Retract";
              retractBtn.onclick = async (e) => {
                e.stopPropagation();
                await retractMessage(msg.message_id, false);
              };
              actionButtons.appendChild(retractBtn);
            }

            messageElement.onclick = () => toggleMessageExpansion(msg.message_id);
            messageElement.appendChild(timestamp);
            messageElement.appendChild(actionButtons);
          }

          messageContainer.appendChild(messageElement);
          tempContainer.appendChild(messageContainer);
        });

        while (tempContainer.firstChild) {
          list.appendChild(tempContainer.firstChild);
        }
        document.body.removeChild(tempContainer);

        if (shouldAutoScroll || wasScrolledToBottom) {
          setTimeout(() => {
            list.scrollTop = list.scrollHeight;
          }, 0);
          shouldAutoScroll = false;
        }
      } catch (err) {
        console.error("Error loading messages:", err);
        list.innerHTML = "";
        noMsgDiv.classList.remove("hidden");
      }
    }

    async function sendMessage() {
      const input = document.getElementById("messageInput");
      const message = input.value.trim();
      if (!message || !currentConvo) return;

      try {
        const res = await fetch(`${apiBase}/sendMessage`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            convo_id: currentConvo,
            user_id: userId,
            message: message
          })
        });
        if (!res.ok) throw new Error(await res.text());

        input.value = "";
        await loadMessages();
      } catch (err) {
        console.error("Failed to send message:", err);
      }
    }

    loadConversations();
    setInterval(() => {
      if (currentConvo) loadMessages();
    }, 3000);
  </script>
</body>
</html>
